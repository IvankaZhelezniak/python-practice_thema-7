from collections import deque

# Створення черги
queue = deque()

# Enqueue: Додавання елементів
queue.append('a')
queue.append('b')
queue.append('c')

print("Черга після додавання елементів:", list(queue))

# Dequeue: Видалення елемента
print("Видалений елемент:", queue.popleft())

print("Черга після видалення елемента:", list(queue))

# Peek: Перегляд першого елемента
print("Перший елемент у черзі:", queue[0])

# IsEmpty: Перевірка на порожнечу
print("Чи черга порожня:", len(queue) == 0)

# Size: Розмір черги
print("Розмір черги:", len(queue))


# Двостороння черга deque
# Створення пустої двосторонньої черги
d = deque()

# Додаємо елементи в чергу
d.append('middle')  # Додаємо 'middle' в кінець черги
d.append('last')    # Додаємо 'last' в кінець черги
d.appendleft('first')  # Додаємо 'first' на початок черги

# Виведення поточного стану черги
print("Черга після додавання елементів:", list(d))

# Видалення та виведення останнього елемента (з правого кінця)
print("Видалений останній елемент:", d.pop())

# Видалення та виведення першого елемента (з лівого кінця)
print("Видалений перший елемент:", d.popleft())

# Виведення поточного стану черги після видалення елементів
print("Черга після видалення елементів:", list(d))




# Ще однією особливістю deque є можливість обмежити розмір Deque:
d1 = deque(maxlen=5)   # Обмеження розміру до 5 елементів
for i in range(10): # Додаємо 10 елементів
    d1.append(i)    # Додасть лише останні 5 елементів, інші будуть видалені

print(d1)

# Як видно з прикладу, нові елементи витісняють старіші, але розмір залишається незмінним. 
# В усьому іншому deque веде себе точно як список Python.


# у нас є список завдань на день, де кожне завдання описано як словник із двома атрибутами: 
# тип завдання (швидке або повільне) та його назва. Наша задача — розподілити ці завдання таким чином, 
# щоб швидкі завдання виконувалися першими. Для цього ми використаємо двосторонню чергу, 
# яка дозволяє нам додавати елементи як на початок, так і в кінець черги.

# Список завдань, де кожне завдання - це словник
tasks = [
    {"type": "fast", "name": "Помити посуд"},
    {"type": "slow", "name": "Подивитись серіал"},
    {"type": "fast", "name": "Вигуляти собаку"},
    {"type": "slow", "name": "Почитати книгу"}
]

# Мета цієї задачі — продемонструвати, як можна використовувати двосторонню чергу для контролю пріоритету завдань.

# Ініціалізація черги завдань
task_queue = deque()
print(task_queue)

# Розподіл завдань у чергу відповідно до їх пріоритету
for task in tasks:
    if task["type"] == "fast":
        task_queue.appendleft(task)  # Додавання на високий пріоритет
        print(f"Додано швидке завдання: {task['name']}")
    else:
        task_queue.append(task)  # Додавання на низький пріоритет
        print(f"Додано повільне завдання: {task['name']}")

# Виконання завдань
while task_queue:                   # Поки черга не порожня
    # Витягуємо завдання з початку черги
    task = task_queue.popleft()
    print(f"Виконується завдання: {task['name']}")
